<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jester: 4D Chaos</title>
    <style>
        /* BASE STYLES */
        html, body { 
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; 
            background-color: #1a1a1a; 
            background-image: radial-gradient(#ffffff 1px, transparent 1px);
            background-size: 24px 24px;
            font-family: 'Courier New', monospace; 
            touch-action: none; user-select: none; 
            transition: background-color 0.5s ease; /* Smooth color shift */
        }
        
        /* CANVAS (The Game World) */
        canvas { 
            display: block; width: 100%; height: 100%; 
            image-rendering: pixelated; 
            transition: transform 0.5s; /* Smooth rotation for 4D */
        }

        /* 4D ANIMATION CLASS */
        .mode-4d {
            animation: spinWorld 4s infinite linear;
        }
        @keyframes spinWorld {
            0% { transform: scale(0.8) rotate(0deg); }
            50% { transform: scale(0.6) rotate(180deg); }
            100% { transform: scale(0.8) rotate(360deg); }
        }

        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; padding: 5px 0; z-index: 10; display: flex; flex-direction: column; align-items: center; pointer-events: none; }

        /* TOP BAR (Progress Bars) */
        #hud-bar {
            display: flex; flex-direction: row; justify-content: center; gap: 4px;
            width: 96%; max-width: 400px;
            background: rgba(0,0,0,0.8); border-radius: 8px; padding: 4px;
            border: 2px solid #555;
        }

        .stat-group {
            flex: 1; display: flex; flex-direction: column; gap: 2px;
        }

        .p-bar {
            height: 10px; width: 100%; background: #333; border: 1px solid #fff;
            position: relative; overflow: hidden;
        }
        
        .p-fill { height: 100%; width: 0%; transition: width 0.2s; }
        .p-txt { font-size: 10px; color: #fff; text-align: center; font-weight: bold; }

        /* TIMER & STATUS */
        #timer-row { margin-top: 5px; text-align: center; }
        #timer { font-size: 28px; font-weight: 900; color: #fff; text-shadow: 2px 2px #000; }
        #status-txt { 
            font-size: 18px; color: #e74c3c; font-weight: 900; 
            text-shadow: 2px 2px #000; height: 24px; 
            text-transform: uppercase; letter-spacing: 1px; 
        }

        /* WARNINGS */
        .warning-glow { box-shadow: 0 0 8px #FFA500; border-color: #FFA500; }

        /* START SCREEN */
        #screen { position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 20; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #fff; backdrop-filter: blur(5px); }
        h1 { font-size: 32px; margin: 0 0 10px 0; color: #FFD700; text-shadow: 4px 4px #000; letter-spacing: -2px;}
        p { font-size: 14px; color: #ccc; max-width: 300px; line-height: 1.5; margin-bottom: 20px; }
        button { padding: 15px 40px; font-size: 20px; background: #FFD700; color: #000; border: 4px solid #fff; cursor: pointer; font-weight: 900; box-shadow: 0 6px #000; transition: transform 0.1s; pointer-events: auto; }
        button:active { transform: translateY(4px); box-shadow: 0 2px #000; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui-layer" class="hidden">
    <div id="hud-bar">
        <div class="stat-group">
            <div class="p-bar"><div id="fill-0" class="p-fill" style="background:#e74c3c"></div></div>
            <div id="txt-0" class="p-txt">0/10</div>
        </div>
        <div class="stat-group">
            <div class="p-bar"><div id="fill-1" class="p-fill" style="background:#3498db"></div></div>
            <div id="txt-1" class="p-txt">0/10</div>
        </div>
        <div class="stat-group">
            <div class="p-bar"><div id="fill-2" class="p-fill" style="background:#2ecc71"></div></div>
            <div id="txt-2" class="p-txt">0/10</div>
        </div>
        <div class="stat-group">
            <div class="p-bar"><div id="fill-3" class="p-fill" style="background:#f1c40f"></div></div>
            <div id="txt-3" class="p-txt">0/10</div>
        </div>
    </div>

    <div id="timer-row">
        <div id="timer">60</div>
        <div id="status-txt"></div>
    </div>
</div>

<div id="screen">
    <h1>4D CHAOS</h1>
    <p>
        <b>Collect ~10 of EACH color!</b><br>
        <span style="color:#FFA500">Buffer Zone: +2 Safe.</span><br>
        +3 Over = RESET.<br><br>
        <b>Special Items:</b><br>
        üçÑ Grow | üíä Shrink<br>
        ü™û Mirror | üåÄ 4D Mode<br>
    </p>
    <button onclick="startGame()">START</button>
</div>

<canvas id="cvs"></canvas>

<script>
// --- CONFIGURATION ---
const INTERNAL_WIDTH = 320; 
const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f'];
const OVERFLOW_BUFFER = 2; 

// --- ASSETS ---
const JESTER_MAP = `
000000001111111100000000
000000011111111110000000
000000111111111111000000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000000111111111111000000
000011001111111100110000
000110000011110000011000
001100110000000011001100
001001111111111111000100
001001101000000101000100
001001101000000101000100
000000111001100111000000
000000011111111110000000
`;

// --- STATE ---
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d', { alpha: true }); 
const timerEl = document.getElementById('timer');
const bodyEl = document.body;

let state = {
    playing: false,
    w: 0, h: 0,
    time: 60, lastTime: 0,
    
    // Logic
    totalNeeded: [10,10,10,10],
    collected: [0,0,0,0],

    // Player (Smaller Size: 24x24)
    p: { x:0, y:0, vx:0, vy:0, baseW:24, baseH:24, scale:1, ground:false, facing:1 },
    
    // Effects
    effects: {
        mirror: false,
        fourD: false,
        timer: 0
    },

    entities: [],
    particles: []
};

// --- CORE ---
function init() {
    state.sprite = parseMap(JESTER_MAP);
    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('screen').style.display = 'none';
    document.getElementById('ui-layer').classList.remove('hidden');
    
    state.playing = true;
    state.time = 60; 
    state.lastTime = performance.now();
    
    clearEffects(); // Reset bg and effects
    
    state.p.x = state.w / 2;
    state.p.y = state.h - 50;
    state.p.vx = 0;
    state.p.scale = 1;
    
    state.entities = [];
    state.particles = [];
    
    // Generate Goals (8-12)
    for(let i=0; i<4; i++) {
        state.totalNeeded[i] = Math.floor(Math.random() * 5) + 8; 
        state.collected[i] = 0;
    }
    updateCounters();
}

function loop(now) {
    if(!state.playing) return requestAnimationFrame(loop);

    let realDt = (now - state.lastTime) / 1000;
    state.lastTime = now;
    
    // Effect Timer
    if(state.effects.timer > 0) {
        state.effects.timer -= realDt;
        if(state.effects.timer <= 0) clearEffects();
    }

    state.time -= realDt; 
    let t = Math.max(0, Math.ceil(state.time));
    timerEl.innerText = t < 10 ? `00:0${t}` : `00:${t}`;
    
    if(state.time <= 0) endGame(false);

    update(realDt);
    draw();
    requestAnimationFrame(loop);
}

// --- PHYSICS ---
function update(dt) {
    const p = state.p;
    let curW = p.baseW * p.scale;
    let curH = p.baseH * p.scale;

    p.vx *= 0.92;
    p.vy += 0.8; // Gravity
    
    p.x += p.vx;
    p.y += p.vy;

    // Floor
    let floorY = state.h; 
    if(p.y + curH > floorY) { p.y = floorY - curH; p.vy = 0; p.ground = true; } 
    else p.ground = false;

    // Walls
    if(p.x < 0) { p.x = 0; p.vx *= -0.5; }
    if(p.x + curW > state.w) { p.x = state.w - curW; p.vx *= -0.5; }
    
    if(Math.abs(p.vx) > 0.1) p.facing = p.vx > 0 ? 1 : -1;

    // Spawning
    if(Math.random() < 0.08) spawnItem('gem'); 
    if(Math.random() < 0.005) spawnItem('bomb');
    if(Math.random() < 0.008) spawnItem('special'); 

    // Entities Logic
    for(let i=state.entities.length-1; i>=0; i--) {
        let e = state.entities[i];
        e.y += e.speed;
        
        // Collision
        if(p.x < e.x + e.w && p.x + curW > e.x &&
           p.y < e.y + e.h && p.y + curH > e.y) {
            handleCollision(e);
            state.entities.splice(i,1);
        } else if(e.y > state.h + 20) {
            state.entities.splice(i,1);
        }
    }
    
    // Particles
    if(state.particles.length > 50) state.particles.splice(0, state.particles.length - 50);
    state.particles.forEach((pt,i) => {
        pt.x += pt.vx; pt.y += pt.vy; pt.life--;
        if(pt.life<=0) state.particles.splice(i,1);
    });
}

function handleCollision(e) {
    if(e.type === 'gem') collectGem(e.idx);
    else if(e.type === 'bomb') hitBomb();
    else if(e.type === 'special') activateSpecial(e.kind);
}

// --- GAME LOGIC ---
function collectGem(idx) {
    if(state.collected[idx] >= state.totalNeeded[idx] + OVERFLOW_BUFFER) {
        triggerOverflow(idx);
        return;
    }
    state.collected[idx]++;
    explode(state.p.x, state.p.y, COLORS[idx], 5);
    updateCounters();
    
    let allDone = true;
    for(let i=0; i<4; i++) if(state.collected[i] < state.totalNeeded[i]) allDone = false;
    if(allDone) endGame(true);
}

function triggerOverflow(idx) {
    statusMsg("‚ö† OVERFLOW! RESET! ‚ö†");
    explode(state.p.x, state.p.y, '#000', 20);
    state.collected[idx] = 0;
    updateCounters();
}

function hitBomb() {
    explode(state.p.x, state.p.y, '#000', 20);
    statusMsg("BOMB HIT -3");
    let candidates = [];
    for(let i=0; i<4; i++) if(state.collected[i]>0) candidates.push(i);
    if(candidates.length > 0) {
        let r = candidates[Math.floor(Math.random()*candidates.length)];
        state.collected[r] = Math.max(0, state.collected[r] - 3);
    }
    updateCounters();
}

function activateSpecial(kind) {
    clearEffects(); 
    state.effects.timer = 8.0; // Effects last 8 seconds

    // BACKGROUND COLOR LOGIC
    if(kind === 'mirror') {
        state.effects.mirror = true;
        bodyEl.style.backgroundColor = "#2c3e50"; // Dark Blue
        statusMsg("ü™û MIRROR MODE ü™û");
    } else if(kind === '4d') {
        state.effects.fourD = true;
        cvs.classList.add('mode-4d');
        bodyEl.style.backgroundColor = "#4a235a"; // Purple
        statusMsg("üåÄ 4D MODE üåÄ");
    } else if(kind === 'grow') {
        state.p.scale = 2.0;
        bodyEl.style.backgroundColor = "#27ae60"; // Green
        statusMsg("üçÑ GIANT üçÑ");
    } else if(kind === 'shrink') {
        state.p.scale = 0.5;
        bodyEl.style.backgroundColor = "#d35400"; // Orange
        statusMsg("üíä TINY üíä");
    }
}

function clearEffects() {
    state.effects.mirror = false;
    state.effects.fourD = false;
    state.p.scale = 1.0;
    
    // Reset Visuals
    cvs.classList.remove('mode-4d');
    bodyEl.style.backgroundColor = "#1a1a1a"; 
    document.getElementById('status-txt').innerText = "";
}

function statusMsg(txt) {
    let el = document.getElementById('status-txt');
    el.innerText = txt;
    el.style.transform = "scale(1.2)";
    setTimeout(()=>el.style.transform="scale(1)", 200);
}

// --- RENDER ---
function draw() {
    ctx.clearRect(0,0,state.w, state.h);
    
    const p = state.p;
    let curW = p.baseW * p.scale;
    let curH = p.baseH * p.scale;

    // Player
    ctx.save();
    ctx.translate(p.x + curW/2, p.y + curH/2);
    ctx.scale(p.facing, 1);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(state.sprite, -curW/2, -curH/2, curW, curH);

    // Hat Visualization (Progress on Head)
    let hatW = (curW/24); 
    let hatH = (curH/21);
    let hatOX = -curW/2 + (6 * hatW); 
    let hatOY = -curH/2 + (2 * hatH);
    let tileW = 3 * hatW; 
    let tileH = 3 * hatH;

    for(let i=0; i<4; i++) {
        let pct = state.collected[i] / state.totalNeeded[i];
        pct = Math.min(pct, 1);
        let fillCount = Math.floor(pct * 4);
        ctx.fillStyle = COLORS[i];
        for(let k=0; k<fillCount; k++) {
            ctx.fillRect(hatOX + (k * tileW), hatOY + (i * tileH), tileW, tileH);
        }
    }
    ctx.restore();

    // Entities
    state.entities.forEach(e => {
        if(e.type === 'gem') drawPixelGem(ctx, e.x, e.y, COLORS[e.idx]);
        else if(e.type === 'bomb') drawBomb(ctx, e.x, e.y);
        else if(e.type === 'special') drawSpecial(ctx, e);
    });

    state.particles.forEach(pt => { ctx.fillStyle=pt.c; ctx.fillRect(pt.x,pt.y,3,3); });
}

function drawSpecial(ctx, e) {
    let x=Math.floor(e.x), y=Math.floor(e.y);
    ctx.fillStyle = '#8e44ad'; 
    ctx.fillRect(x,y,20,20);
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(x,y,20,20);
    
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    let icon = "?";
    if(e.kind==='mirror') icon="ü™û";
    if(e.kind==='4d') icon="üåÄ";
    if(e.kind==='grow') icon="üçÑ";
    if(e.kind==='shrink') icon="üíä";
    ctx.fillText(icon, x+10, y+10);
}

function drawBomb(ctx, x, y) {
    x=Math.floor(x); y=Math.floor(y);
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(x+3, y+3, 12, 12);
    ctx.fillStyle = '#000'; ctx.fillRect(x+3, y+3, 12, 12);
    ctx.fillStyle = '#f00'; ctx.fillRect(x+8, y-2, 2, 2);
}

function drawPixelGem(ctx, x, y, c) {
    x=Math.floor(x); y=Math.floor(y);
    ctx.fillStyle = '#000'; ctx.fillRect(x+1, y, 14, 16); 
    ctx.fillStyle = c; ctx.fillRect(x+3, y+2, 10, 12); 
    ctx.fillStyle = '#fff'; ctx.fillRect(x+4, y+3, 3, 3); 
}

function spawnItem(type) {
    let x = Math.random() * (state.w - 30) + 15;
    let baseSpeed = (3 + Math.random() * 2); 
    
    if(type === 'gem') {
        state.entities.push({type:'gem', x, y:-20, w:16, h:16, idx:Math.floor(Math.random()*4), speed: baseSpeed});
    } else if(type === 'bomb') {
        state.entities.push({type:'bomb', x, y:-20, w:18, h:18, speed: baseSpeed + 0.5});
    } else if(type === 'special') {
        const kinds = ['mirror', '4d', 'grow', 'shrink'];
        let kind = kinds[Math.floor(Math.random()*kinds.length)];
        state.entities.push({type:'special', kind, x, y:-20, w:20, h:20, speed: 2.5});
    }
}

function updateCounters() {
    for(let i=0; i<4; i++) {
        let cur = state.collected[i];
        let tot = state.totalNeeded[i];
        
        // Update Text
        document.getElementById(`txt-${i}`).innerText = `${cur}/${tot}`;
        
        // Update Bar Width
        let pct = Math.min((cur / tot) * 100, 100);
        let fillEl = document.getElementById(`fill-${i}`);
        fillEl.style.width = `${pct}%`;

        // Check Buffer Warning (If over 100% but safe)
        if(cur > tot && cur <= tot + OVERFLOW_BUFFER) {
            fillEl.style.backgroundColor = "#FFA500"; // Orange Warning
        } else {
            fillEl.style.backgroundColor = COLORS[i]; // Normal Color
        }
    }
}

// --- INPUT ---
let tx=0, ty=0;
window.addEventListener('touchstart', e=>{ tx=e.touches[0].clientX; ty=e.touches[0].clientY; }, {passive:false});
window.addEventListener('touchend', e=>{
    if(e.target.tagName==='BUTTON') return;
    let dx = e.changedTouches[0].clientX - tx;
    let dy = e.changedTouches[0].clientY - ty;

    if(state.effects.mirror) dx = -dx; 
    
    if(dy < -30 && Math.abs(dy) > Math.abs(dx)) { 
        if(state.p.ground) { state.p.vy = -12; state.p.ground=false; } 
    } 
    else if(Math.abs(dx) > 10) {
        let power = Math.min(Math.abs(dx) / 10, 8); 
        state.p.vx += (dx>0?1:-1) * (2 + power); 
    }
});

function parseMap(str) {
    let lines = str.trim().split(/\n+/);
    let c = document.createElement('canvas');
    c.width = lines[0].length; c.height = lines.length;
    let cx = c.getContext('2d');
    cx.fillStyle = '#fff'; 
    lines.forEach((row,y) => { for(let x=0; x<row.length; x++) if(row[x]==='1') cx.fillRect(x,y,1,1); });
    return c;
}
function explode(x,y,c,n) { for(let i=0; i<n; i++) state.particles.push({x,y,vx:(Math.random()-.5)*6,vy:(Math.random()-.5)*6,c,life:15}); }

function resize() { 
    let aspect = window.innerHeight / window.innerWidth;
    state.w = INTERNAL_WIDTH;
    state.h = INTERNAL_WIDTH * aspect;
    cvs.width = state.w;
    cvs.height = state.h;
    state.p.y = state.h - 50;
}

function endGame(win) {
    state.playing = false;
    document.getElementById('screen').style.display = 'flex';
    document.getElementById('ui-layer').classList.add('hidden');
    document.querySelector('h1').innerText = win ? "VICTORY!" : "TIME'S UP";
    document.querySelector('p').innerHTML = win ? "You conquered the Chaos!" : "Try again!";
    clearEffects();
}

init();
</script>
</body>
</html>
