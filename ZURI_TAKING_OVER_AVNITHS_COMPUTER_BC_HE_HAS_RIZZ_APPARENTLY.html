<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Sir Jester's Quest</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body { 
        margin: 0; padding: 0; overflow: hidden; 
        background: #fff; 
        font-family: 'Press Start 2P', cursive;
        touch-action: none; user-select: none; -webkit-user-select: none; 
    }
    
    canvas { display: block; width: 100%; height: 100%; }

    /* UI LAYERS */
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        display: flex; flex-direction: column; justify-content: space-between;
    }

    /* STORY BOX */
    #story-container {
        position: absolute; bottom: 5%; left: 5%; width: 90%;
        background: #fff; border: 0.5vmin solid #000;
        padding: 2vmin; box-sizing: border-box;
        text-align: center; pointer-events: auto;
        box-shadow: 1vmin 1vmin 0px rgba(0,0,0,0.2);
    }

    #story-text {
        font-size: 2.5vmin; line-height: 1.6; color: #000; margin-bottom: 2vmin;
        min-height: 10vmin; display: flex; align-items: center; justify-content: center;
    }

    /* BUTTONS */
    .btn {
        background: #000; color: #fff; border: 0.4vmin solid #000; 
        padding: 1.5vmin 4vmin; font-family: inherit; font-size: 2.5vmin;
        cursor: pointer; box-shadow: 0.5vmin 0.5vmin 0 #888;
        display: inline-block;
    }
    .btn:active { transform: translate(0.3vmin, 0.3vmin); box-shadow: 0.2vmin 0.2vmin 0 #888; }

    /* HUD OVERLAY - Top Right */
    #game-hud {
        position: absolute; top: 2vmin; right: 2vmin;
        display: none; 
        flex-direction: column; 
        align-items: flex-end; 
        gap: 1vmin;
        pointer-events: none;
    }

    /* TIMER */
    #timer {
        font-size: 3.75vmin; 
        color: #000; 
        text-shadow: 0.2vmin 0.2vmin 0 #fff;
        margin-bottom: 0.5vmin;
        text-align: right;
        font-weight: bold;
        transition: color 0.3s;
    }

    /* PANIC MODE ANIMATION (Last 30s) */
    @keyframes panicPulse {
        0% { transform: scale(1) rotate(0deg); }
        25% { transform: scale(1.2) rotate(-5deg); }
        50% { transform: scale(1.2) rotate(5deg); }
        75% { transform: scale(1.1) rotate(-2deg); }
        100% { transform: scale(1) rotate(0deg); }
    }

    #timer.panic {
        color: #f00 !important;
        text-shadow: 0.3vmin 0.3vmin 0 #500;
        animation: panicPulse 0.5s infinite;
    }

    .hud-row {
        display: flex; align-items: center; gap: 0.8vmin;
        background: rgba(255,255,255,0.9);
        padding: 0.8vmin; border: 0.4vmin solid #000;
        position: relative;
        width: 42vmin; 
        box-sizing: border-box;
    }
    
    .color-icon { 
        width: 4.5vmin; height: 4.5vmin; 
        border: 0.4vmin solid #000; flex-shrink: 0; 
    }
    
    /* PROGRESS BARS */
    .bar-container {
        flex-grow: 1; 
        height: 4.5vmin; 
        background: #ccc; border: 0.4vmin solid #000;
        position: relative;
    }
    .bar-fill {
        height: 100%; width: 0%; 
        transition: width 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28); 
    }
    .hud-txt { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 2.25vmin; 
        color: #000; text-shadow: 0.2vmin 0.2vmin 0 #fff; z-index: 2;
    }

    /* SPILL MESSAGE */
    .spill-msg {
        position: absolute; top: 50%; right: 105%; transform: translateY(-50%);
        font-size: 2.5vmin; color: #d00; white-space: nowrap; 
        font-weight: bold; opacity: 0; pointer-events: none;
        text-shadow: 0.2vmin 0.2vmin 0 #fff;
        background: rgba(255,255,255,0.9);
        padding: 0.5vmin; border: 0.2vmin solid #000;
        z-index: 10;
    }
    .spill-anim {
        animation: popOut 1s ease-out forwards;
    }

    @keyframes popOut {
        0% { opacity: 1; transform: translateY(-50%) translateX(0) scale(1); }
        100% { opacity: 0; transform: translateY(-50%) translateX(-2vmin) scale(1.2); }
    }

    /* MAX VIBRATION */
    @keyframes vibrate {
        0% { transform: translate(0); }
        20% { transform: translate(-0.3vmin, 0.3vmin); }
        40% { transform: translate(-0.3vmin, -0.3vmin); }
        60% { transform: translate(0.3vmin, 0.3vmin); }
        80% { transform: translate(0.3vmin, -0.3vmin); }
        100% { transform: translate(0); }
    }
    .hud-row.max {
        border-color: #d00;
        animation: vibrate 0.3s linear infinite;
        background: #fff0f0;
    }
    .hud-row.max .hud-txt { color: #d00; font-weight: bold; }

    /* END SCREEN BARS */
    #end-bars {
        display: none; width: 100%; max-width: 50vmin;
        margin: 2vmin auto;
        background: #eee; padding: 2vmin; border: 0.4vmin solid #000;
        box-sizing: border-box;
    }
    .end-row {
        display: flex; align-items: center; justify-content: space-between;
        margin-bottom: 1.5vmin; font-size: 2vmin; width: 100%;
    }
    .end-label { width: 4vmin; text-align: center; font-weight: bold; }
    .progress-track {
        flex-grow: 1; height: 3vmin; background: #ccc; margin: 0 2vmin; border: 0.3vmin solid #000;
        position: relative;
    }

</style>
</head>
<body oncontextmenu="return false;">

<div id="ui-layer">
    <div id="game-hud">
        <div id="timer">1:30</div>

        <div class="hud-row" id="row-R">
            <div class="spill-msg" id="msg-R"></div>
            <div class="color-icon" style="background:#f00"></div>
            <div class="bar-container"><div id="bar-R" class="bar-fill" style="background:#f00"></div><span id="cnt-R" class="hud-txt">0/3</span></div>
        </div>
        <div class="hud-row" id="row-Y">
            <div class="spill-msg" id="msg-Y"></div>
            <div class="color-icon" style="background:#ff0"></div>
            <div class="bar-container"><div id="bar-Y" class="bar-fill" style="background:#ff0"></div><span id="cnt-Y" class="hud-txt">0/2</span></div>
        </div>
        <div class="hud-row" id="row-B">
            <div class="spill-msg" id="msg-B"></div>
            <div class="color-icon" style="background:#00f"></div>
            <div class="bar-container"><div id="bar-B" class="bar-fill" style="background:#00f"></div><span id="cnt-B" class="hud-txt">0/4</span></div>
        </div>
        <div class="hud-row" id="row-G">
            <div class="spill-msg" id="msg-G"></div>
            <div class="color-icon" style="background:#4dff4d"></div>
            <div class="bar-container"><div id="bar-G" class="bar-fill" style="background:#4dff4d"></div><span id="cnt-G" class="hud-txt">0/1</span></div>
        </div>
    </div>

    <div id="story-container">
        <div id="story-text">Loading...</div>
        <div id="end-bars"></div>
        <button id="main-btn" class="btn" onclick="handleBtn()">NEXT ></button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// --- CONFIG ---
const MAX_TIME = 90; 
const COLORS = { R:'#f00', Y:'#ff0', B:'#00f', G:'#4dff4d' };
const LIGHT_COLORS = { R:'#f88', Y:'#ffb', B:'#66f', G:'#99ff99' }; 

let TARGETS = { R:0, Y:0, B:0, G:0 }; 
let REGION_MAP = {}; 

// --- MUSIC CONFIG ---
const F = {
    'A3': 220.00, 'B3': 246.94, 'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G#4': 415.30,
    'A4': 440.00, 'B4': 493.88, 'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G#5': 830.61, 'A5': 880.00
};

const SONG_DATA = [
    ['E5', 'A3', 2, true], ['C5', 'E4', 2, false], ['A4', 'A3', 2, true], ['C5', 'E4', 2, false],
    ['B4', 'B3', 2, true], ['G#4', 'E4', 2, false], ['E4', 'B3', 2, true], ['G#4', 'E4', 2, false],
    ['A4', 'A3', 2, true], ['B4', 'E4', 2, false], ['C5', 'A3', 2, true], ['D5', 'E4', 2, false],
    ['E5', 'C#5', 4, true], ['C#5', 'A4', 4, true],
    ['D5', 'D4', 2, true], ['F5', 'F4', 2, false], ['A5', 'D4', 2, true], ['F5', 'A4', 2, false],
    ['E5', 'A3', 2, true], ['C5', 'E4', 2, false], ['E5', 'A3', 2, true], ['C5', 'E4', 2, false],
    ['D5', 'B3', 2, true], ['F5', 'D4', 2, false], ['B4', 'E4', 2, true], ['D5', 'G#4', 2, false],
    ['C5', 'A3', 2, true], ['B4', 'E4', 2, false], ['A4', 'A3', 4, true]
];

// Audio State
let audioCtx = null;
let isPlayingMusic = false;
let currentNoteIndex = 0;
let nextNoteTime = 0;
let currentTempo = 100;
const START_TEMPO = 100;
const TARGET_TEMPO = 240;

// --- ASSETS ---
const JESTER_MAP = [
    ".......#.#.......",
    "......#A#B#......", 
    ".....#A#C#B#.....", 
    ".....#######.....",
    ".....#.....#.....", 
    ".....#######.....",
    "....##DDDDD##....", 
    "...#E#FFFFF#G#...", 
    "...#E#FFFFF#G#...", 
    "..##E#######G##..",
    "..#HH#.....#II#..", 
    "..#HH#.....#II#..",
    ".#JJ#.......#KK#.", 
    ".####.......####."
];

const GEM_SPRITE = [
    "...#...",
    "..#A#..",
    ".#AMA#.",
    "#MAMAM#",
    ".#MMM#.",
    "..#M#..",
    "...#..."
];

const ADJACENCY = {
    'A': ['C'], 'B': ['C'], 'C': ['A', 'B', 'D'], 
    'D': ['C', 'E', 'F', 'G'], 'E': ['D', 'F', 'H'],
    'F': ['D', 'E', 'G', 'H', 'I'], 'G': ['D', 'F', 'I'],
    'H': ['E', 'F', 'J'], 'I': ['F', 'G', 'K'],
    'J': ['H'], 'K': ['I']
};

const SPRITES = {
    PRINCESS_HAPPY: [
        "...11111...", "..1111111..", ".111111111.", ".1.1.1.1.1.", ".111111111.",
        "..1111111..", "..1111111..", ".111111111.", "11111111111"
    ],
    PRINCESS_MAD: [
        "...11111...", "..1111111..", ".11R111R11.", ".1.1.1.1.1.", ".111111111.",
        "..1111111..", "..1111111..", ".111111111.", "11111111111"
    ],
    HAT: [ "...Y...", "..YRY..", ".YRYRY.", "YRYRYRY", "GBGBGBG", ".GBGBG.", "..GBG.." ]
};

const STORY = [
    { txt: "Sir Jester loves his job!\nHe makes the princess laugh.", s1: 'PLAYER', s2: 'PRINCESS_HAPPY', anim: 'hop' },
    { txt: "But recently there's been an issue...", s1: 'PLAYER', s2: 'PRINCESS_MAD', anim: 'shake' },
    { txt: "The princess has been sad...", s1: 'PRINCESS_MAD', scaleMulti: 1.5, anim: 'hop' },
    { txt: "And this makes Sir Jester sad too...", s1: 'PLAYER', scaleMulti: 1.5, anim: 'hop' },
    { txt: "But Sir Jester has an idea!", s1: 'PLAYER', scaleMulti: 1.5, anim: 'jump' },
    { txt: "To make a colorful hat\nand make her laugh again.", s1: 'HAT', scaleMulti: 2.0, anim: 'float' },
    { txt: "FLICK UP to Jump!\nCollect the gems!", s1: 'PLAYER', jump: true, anim: 'run' }
];

// --- ENGINE VARIABLES ---
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let pxScale = 1; 

let gameState = 'STORY'; 
let slideIdx = 0;
let timeLeft = MAX_TIME;

let player = { x: 0, y: 0, w: 0, h: 0, vx: 0, vy: 0, ground: false };
let spillTimer = 0; 
let spillColor = '#fff';
let shineTimers = {}; 

let activePointers = {}; 
let input = { active: false };
let items = [];
let particles = [];
let floatText = []; 
let collected = { R:0, Y:0, B:0, G:0 };
let winCondition = false;

// --- INITIALIZATION ---
function init() {
    window.addEventListener('resize', resize);
    window.addEventListener('contextmenu', e => e.preventDefault());
    generateColorMap(); 
    resize();
    updateStoryUI();
    requestAnimationFrame(loop);
}

function generateColorMap() {
    const regions = Object.keys(ADJACENCY);
    const colorKeys = ['R', 'Y', 'B', 'G'];
    const assignments = {};
    regions.sort(() => Math.random() - 0.5);

    for (let r of regions) {
        let choices = [...colorKeys].sort(() => Math.random() - 0.5);
        let validColor = null;

        for (let c of choices) {
            let conflict = false;
            for (let neighbor of ADJACENCY[r]) {
                if (assignments[neighbor] === c) { conflict = true; break; }
            }
            if (!conflict) { validColor = c; break; }
        }
        assignments[r] = validColor || choices[0];
    }

    REGION_MAP = {};
    TARGETS = { R:0, Y:0, B:0, G:0 };
    let colorCounts = { R:0, Y:0, B:0, G:0 };
    const sortedRegions = Object.keys(ADJACENCY).sort();
    
    for (let r of sortedRegions) {
        let c = assignments[r];
        colorCounts[c]++;
        REGION_MAP[r] = { c: c, i: colorCounts[c] };
    }
    TARGETS = colorCounts;
}

function resize() {
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;
    let targetH = cvs.height / 5;
    pxScale = targetH / 14; 
    player.w = 17 * pxScale;
    player.h = 14 * pxScale;
    if(player.y > cvs.height) player.y = cvs.height - player.h - 10;
}

function loop() {
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    if (gameState === 'STORY') drawStory(); 
    else if (gameState === 'GAME') { updatePhysics(); drawGame(); }
    else if (gameState === 'END') drawEndScene();
    requestAnimationFrame(loop);
}

// --- AUDIO SYSTEM ---
function initAudio() {
    if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

function startMusic() {
    if(!audioCtx) initAudio();
    currentNoteIndex = 0;
    nextNoteTime = audioCtx.currentTime + 0.1;
    isPlayingMusic = true;
}

function stopMusic() {
    isPlayingMusic = false;
}

function playTone(freq, type, time, duration, vol) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.value = freq;
    
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(vol, time + 0.01); 
    gain.gain.exponentialRampToValueAtTime(0.001, time + duration - 0.01);
    
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(time); osc.stop(time + duration);
}

function playNoise(time, vol) {
    if(!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.04;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'highpass'; filter.frequency.value = 2200;
    const gain = audioCtx.createGain();
    
    gain.gain.setValueAtTime(vol, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.03);
    
    noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
    noise.start(time);
}

// --- NEW SFX: GLASS CLANK (Collection) ---
function playGlassClank() {
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    // Main "ping"
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.frequency.setValueAtTime(2000, t);
    gain.gain.setValueAtTime(0.1, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.1);

    // Overtone for "glassy" texture
    const osc2 = audioCtx.createOscillator();
    const gain2 = audioCtx.createGain();
    osc2.type = 'triangle';
    osc2.frequency.setValueAtTime(3500, t); // Non-harmonic
    gain2.gain.setValueAtTime(0.05, t);
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc2.connect(gain2); gain2.connect(audioCtx.destination);
    osc2.start(t); osc2.stop(t + 0.1);
}

// --- NEW SFX: GLASS BREAK (Overflow) ---
function playGlassBreak() {
    if(!audioCtx) return;
    const t = audioCtx.currentTime;

    // 1. Noise Burst (The impact)
    const bufferSize = audioCtx.sampleRate * 0.3; 
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000; // Remove low rumble
    const noiseGain = audioCtx.createGain();
    noiseGain.gain.setValueAtTime(0.3, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    noise.connect(filter); filter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
    noise.start(t);

    // 2. High pitched "shards" (The debris)
    for(let i=0; i<3; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(2000 + (Math.random()*3000), t);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1 + (Math.random()*0.2));
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + 0.3);
    }
}

// --- RESTORED: GONG (Game Over) ---
function playGong() {
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    // Metallic crash using non-harmonic overtones
    const freqs = [100, 150, 220, 310, 430];
    freqs.forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.value = f;
        osc.type = 'triangle';
        gain.gain.setValueAtTime(0.3 / (i+1), t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 3 + (i*0.5));
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + 5);
    });
}

function playFanfare() {
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const notes = [523.25, 659.25, 783.99, 1046.50];
    notes.forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = f;
        const start = t + (i * 0.15);
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(0.15, start + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, start + 0.8);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(start); osc.stop(start + 1.0);
    });
}

function updateMusicScheduler() {
    if (!isPlayingMusic || !audioCtx) return;
    let elapsed = MAX_TIME - timeLeft;
    let progress = Math.min(elapsed / MAX_TIME, 1);
    let intensity = Math.pow(progress, 3); 
    currentTempo = START_TEMPO + (TARGET_TEMPO - START_TEMPO) * intensity;
    while (nextNoteTime < audioCtx.currentTime + 0.1) {
        scheduleNote(currentNoteIndex, nextNoteTime);
        const sixteenthTime = (60 / currentTempo) / 4;
        const dur = SONG_DATA[currentNoteIndex][2];
        nextNoteTime += sixteenthTime * dur;
        currentNoteIndex = (currentNoteIndex + 1) % SONG_DATA.length;
    }
}

function scheduleNote(index, time) {
    const [mNote, bNote, dur, beat] = SONG_DATA[index];
    const sixteenth = (60 / currentTempo) / 4;
    const seconds = sixteenth * dur;
    playTone(F[mNote], 'sawtooth', time, seconds, 0.04);
    playTone(F[bNote], 'triangle', time, seconds, 0.08);
    if (beat) playNoise(time, 0.03);
}

// --- STORY ---
function updateStoryUI() {
    if(gameState !== 'STORY') return;
    const s = STORY[slideIdx];
    document.getElementById('story-text').innerText = s.txt;
    const btn = document.getElementById('main-btn');
    btn.innerText = (slideIdx === STORY.length - 1) ? "START GAME" : "NEXT >";
}

function handleBtn() {
    initAudio();
    if (gameState === 'STORY') {
        slideIdx++;
        if (slideIdx >= STORY.length) startGame();
        else updateStoryUI();
    } else if (gameState === 'END') location.reload(); 
}

function drawStory() {
    const s = STORY[slideIdx];
    const cx = cvs.width / 2;
    const cy = cvs.height / 2 - player.h; 
    const scale = (s.scaleMulti || 1) * pxScale * 0.8; 
    let yOff = 0; let t = Date.now();
    if (s.anim === 'hop') yOff = Math.abs(Math.sin(t/300)) * -20;
    if (s.anim === 'float') yOff = Math.sin(t/500) * 10;
    if (s.anim === 'jump') yOff = Math.abs(Math.sin(t/150)) * -30;

    if (s.s2) {
        drawCustomSprite(s.s1, cx - (scale*10), cy + yOff, scale);
        drawCustomSprite(s.s2, cx + (scale*10), cy + yOff, scale);
    } else {
        drawCustomSprite(s.s1, cx, cy + yOff, scale);
    }
}

// --- GAME ---
function startGame() {
    gameState = 'GAME';
    document.getElementById('story-container').style.display = 'none';
    document.getElementById('game-hud').style.display = 'flex';
    document.getElementById('timer').classList.remove('panic');
    player.x = cvs.width/2 - player.w/2;
    player.y = cvs.height - player.h - 10;
    player.vx = 0; player.vy = 0;
    collected = { R:0, Y:0, B:0, G:0 };
    updateHUD();
    startMusic(); 
}

function updatePhysics() {
    timeLeft -= 0.016;
    let m = Math.floor(timeLeft/60);
    let s = Math.floor(timeLeft%60);
    const timerEl = document.getElementById('timer');
    timerEl.innerText = `${m}:${s<10?'0'+s:s}`;
    
    if (timeLeft <= 30 && !timerEl.classList.contains('panic')) timerEl.classList.add('panic');
    if(timeLeft <= 0) endGame(false);
    updateMusicScheduler();

    let moveDir = 0;
    const center = cvs.width / 2; 
    for (let id in activePointers) {
        const p = activePointers[id];
        if (p.x < center) moveDir = -1;
        if (p.x > center) moveDir = 1;
    }

    const accel = pxScale * 0.2;
    const maxSpd = pxScale * 1.5;
    if (moveDir !== 0) player.vx += moveDir * accel;
    else {
        if (player.ground) player.vx *= 0.6; else player.vx *= 0.96; 
    }
    player.vx = Math.max(-maxSpd, Math.min(maxSpd, player.vx));
    if (Math.abs(player.vx) < 0.1) player.vx = 0;

    player.vy += pxScale * 0.08; 
    player.x += player.vx;
    player.y += player.vy;

    const GROUND_Y = cvs.height - (pxScale * 4); 
    const LANDING_Y = GROUND_Y - player.h;

    if (player.y > LANDING_Y) { 
        player.y = LANDING_Y; 
        player.vy = 0; 
        player.ground = true; 
    }

    if (player.x < 0) { player.x = 0; player.vx = 0; }
    if (player.x > cvs.width - player.w) { player.x = cvs.width - player.w; player.vx = 0; }
    
    if (spillTimer > 0) spillTimer--;
    
    // Decrement Shine Timers
    for (let k in shineTimers) {
        if (shineTimers[k] > 0) shineTimers[k]--;
    }

    // Spawning
    let difficulty = (MAX_TIME - timeLeft) / MAX_TIME; 
    let spawnRate = 0.013 + (difficulty * 0.04); 
    if (Math.random() < spawnRate) spawnItem();

    for (let i = items.length - 1; i >= 0; i--) {
        let it = items[i];
        it.y += pxScale * 0.8; 

        if (checkRectCollide(player, {x:it.x, y:it.y, w:it.w, h:it.h})) {
            if (collected[it.type] >= TARGETS[it.type]) {
                // OVERFLOW
                playGlassBreak(); // NEW SFX
                triggerSpill(it.type);
            } else {
                // SUCCESS COLLECT
                collected[it.type]++;
                playGlassClank(); // NEW SFX
                
                // TRIGGER SHINE ON THE NEWLY FILLED REGION
                for(let r in REGION_MAP) {
                    if (REGION_MAP[r].c === it.type && REGION_MAP[r].i === collected[it.type]) {
                        shineTimers[r] = 30; 
                    }
                }
                
                // TRIGGER COLLECTION ANIMATION
                floatText.push({
                    x: player.x + player.w/2, y: player.y,
                    txt: "+1", color: it.color, life: 40
                });
                
                for(let p=0; p<5; p++) {
                    particles.push({
                        x: player.x + player.w/2, y: player.y + player.h/2,
                        vx: (Math.random()-0.5)*pxScale, vy: -Math.random()*pxScale,
                        color: '#fff', life: 20, size: pxScale*2, type: 'sparkle'
                    });
                }
                
                updateHUD();
                checkWin();
            }
            items.splice(i, 1);
        } else if (it.y > cvs.height) {
            items.splice(i, 1);
        }
    }

    // Update Particles
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        if (p.type !== 'sparkle') p.vy += pxScale * 0.05; 
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    }
    
    // Update Float Text
    for(let i=floatText.length-1; i>=0; i--) {
        let f = floatText[i];
        f.y -= pxScale * 0.1;
        f.life--;
        if(f.life <= 0) floatText.splice(i, 1);
    }
}

function triggerSpill(type) {
    let current = collected[type];
    if (current <= 0) return; 
    let loss = Math.floor(Math.random() * 3) + 1;
    if (loss > current) loss = current;
    collected[type] -= loss;

    spillTimer = 20; 
    spillColor = COLORS[type]; // Set color for flash
    
    // Spill Debris Animation
    for(let i=0; i<loss*4; i++) {
        particles.push({
            x: player.x + player.w/2,
            y: player.y + player.h/2,
            vx: (Math.random() - 0.5) * (pxScale * 3), 
            vy: -(Math.random() * (pxScale * 3)),
            color: COLORS[type],
            life: 60,
            size: player.w / 5,
            type: 'debris'
        });
    }

    updateHUD();
    showSpillText(type, loss);
}

function showSpillText(type, amount) {
    const el = document.getElementById(`msg-${type}`);
    el.innerText = `-${amount} SPILLED!`;
    el.classList.remove('spill-anim');
    void el.offsetWidth; 
    el.classList.add('spill-anim');
}

function spawnItem() {
    const keys = ['R', 'Y', 'B', 'G'];
    const type = keys[Math.floor(Math.random() * keys.length)];
    const gSize = player.w * 0.35; 
    items.push({
        x: Math.random() * (cvs.width - gSize),
        y: -gSize, w: gSize, h: gSize, type: type, color: COLORS[type]
    });
}

function checkRectCollide(p, it) {
    return (p.x < it.x + it.w && p.x + p.w > it.x &&
            p.y < it.y + it.h && p.y + p.h > it.y);
}

function updateHUD() {
    for(let k in TARGETS) {
        if(TARGETS[k] === 0) {
            document.getElementById(`row-${k}`).style.display = 'none';
            continue;
        } else {
            document.getElementById(`row-${k}`).style.display = 'flex';
        }

        let el = document.getElementById(`cnt-${k}`);
        let row = document.getElementById(`row-${k}`);
        let bar = document.getElementById(`bar-${k}`);
        
        let cur = collected[k];
        let tot = TARGETS[k];
        let pct = (cur / tot) * 100;
        
        bar.style.width = `${pct}%`;

        if(cur >= tot) {
            el.innerText = "MAX";
            row.classList.add('max');
        } else {
            el.innerText = `${cur}/${tot}`;
            row.classList.remove('max');
        }
    }
}

function checkWin() {
    let win = true;
    for(let k in TARGETS) if(collected[k] < TARGETS[k]) win = false;
    if(win) endGame(true);
}

function endGame(win) {
    gameState = 'END';
    winCondition = win;
    stopMusic(); 
    
    if(win) playFanfare();
    else playGong(); // RESTORED GONG CALL
    
    document.getElementById('game-hud').style.display = 'none';
    const box = document.getElementById('story-container');
    box.style.display = 'block';
    const txt = document.getElementById('story-text');
    if (win) txt.innerHTML = "It’s the perfect color combo!<br>The princess loves your hat!<br>She can’t stop laughing!";
    else txt.innerHTML = "There’s not enough colors...<br>The princess thinks your hat is ugly.<br>She guillotines you.";

    document.getElementById('end-bars').style.display = 'block';
    const barBox = document.getElementById('end-bars');
    barBox.innerHTML = ''; 
    for(let k in TARGETS) {
        if(TARGETS[k] === 0) continue; 
        let pct = Math.min(100, (collected[k] / TARGETS[k]) * 100);
        barBox.innerHTML += `
            <div class="end-row">
                <span class="end-label">${k}</span>
                <div class="progress-track"><div class="bar-fill" style="background:${COLORS[k]}; width:${pct}%"></div></div>
                <span class="end-label">${collected[k]}/${TARGETS[k]}</span>
            </div>`;
    }
    document.getElementById('main-btn').innerText = "TRY AGAIN";
}

// --- RENDERERS ---
function drawGame() {
    ctx.save();
    if (timeLeft <= 30) {
        const shakeIntensity = ((30 - timeLeft) / 30) * (pxScale * 0.5); 
        ctx.translate((Math.random()-0.5)*shakeIntensity*10, (Math.random()-0.5)*shakeIntensity*10);
    }
    
    // SPECIFIC COLOR FLASH on Spill
    if (spillTimer > 0) {
         ctx.save();
         ctx.globalAlpha = spillTimer / 60;
         ctx.fillStyle = spillColor; // Use specific color
         ctx.fillRect(0, 0, cvs.width, cvs.height);
         ctx.restore();
    }

    // GROUND
    const GROUND_Y = cvs.height - (pxScale * 4); 
    ctx.fillStyle = '#f2f2f2'; 
    ctx.fillRect(-100, GROUND_Y, cvs.width + 200, cvs.height - GROUND_Y + 100);
    ctx.fillStyle = '#000';
    ctx.fillRect(-100, GROUND_Y, cvs.width + 200, Math.max(2, pxScale * 0.5));

    let bob = Math.sin(Date.now() / (Math.abs(player.vx) > 0.1 ? 50 : 300)) * (player.h * 0.05);
    let spillShake = 0;
    if (spillTimer > 0) spillShake = (Math.random() - 0.5) * (pxScale * 2);

    drawPlayerSprite(player.x + spillShake, player.y + bob, pxScale);
    
    // ITEMS
    items.forEach(it => {
        const colorMap = { '#': '#000', 'M': it.color, 'A': LIGHT_COLORS[it.type] };
        drawMap(GEM_SPRITE, it.x, it.y, pxScale * 0.8, colorMap);
    });

    // PARTICLES
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / (p.type==='sparkle'?30:60);
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.globalAlpha = 1.0;
    });
    
    // FLOAT TEXT
    ctx.font = `bold ${pxScale*2}px "Courier New"`;
    ctx.textAlign = "center";
    floatText.forEach(f => {
        ctx.fillStyle = '#000';
        ctx.fillText(f.txt, f.x + 2, f.y + 2); // shadow
        ctx.fillStyle = f.color;
        ctx.fillText(f.txt, f.x, f.y);
    });

    ctx.restore();
}

function drawEndScene() {
    const cx = cvs.width/2;
    const cy = cvs.height/2 - (player.h * 1.5); 
    const scale = pxScale * 1.5; 
    
    if (winCondition) {
        drawCustomSprite('PRINCESS_HAPPY', cx + (15*pxScale), cy, scale);
        drawPlayerSprite(cx - (15*pxScale), cy + (5*pxScale), scale);
    } else {
        drawCustomSprite('PRINCESS_MAD', cx + (15*pxScale), cy, scale);
        drawPlayerSprite(cx - (15*pxScale), cy + (5*pxScale), scale);
    }
}

function drawMap(map, x, y, scale, colorMap) {
    const w = map[0].length;
    const h = map.length;
    for(let r=0; r<h; r++) {
        for(let c=0; c<w; c++) {
            let char = map[r][c];
            if (char === '.') continue;
            ctx.fillStyle = colorMap[char] || '#000';
            ctx.fillRect(x + c*scale, y + r*scale, scale+0.5, scale+0.5);
        }
    }
}

function drawPlayerSprite(x, y, scale) {
    const map = JESTER_MAP;
    const w = map[0].length;
    const h = map.length;

    for(let r=0; r<h; r++) {
        for(let c=0; c<w; c++) {
            let char = map[r][c];
            if (char === '.') continue;
            
            ctx.fillStyle = '#fff';
            if (char === '#') ctx.fillStyle = '#000';
            else if (REGION_MAP[char]) {
                const reg = REGION_MAP[char];
                
                // SHINE LOGIC
                if (shineTimers[char] && shineTimers[char] > 0) {
                     // Flash White/Bright Yellow
                     ctx.fillStyle = (Math.floor(shineTimers[char]/4)%2===0) ? '#fff' : '#ffffaa';
                }
                else if (spillTimer > 0 && Math.floor(spillTimer / 4) % 2 === 0) {
                    ctx.fillStyle = spillColor; 
                }
                else if (collected[reg.c] >= reg.i) {
                    ctx.fillStyle = COLORS[reg.c];
                } 
                else {
                    ctx.fillStyle = '#ddd';
                }
            }
            ctx.fillRect(x + c*scale, y + r*scale, scale+0.5, scale+0.5);
        }
    }
}

function drawCustomSprite(name, cx, cy, scale) {
    if (name === 'PLAYER') {
        drawPlayerSprite(cx - (17*scale)/2, cy - (14*scale)/2, scale);
        return;
    }
    const map = SPRITES[name];
    if(!map) return;
    const w = map[0].length;
    const h = map.length;
    const startX = cx - (w * scale) / 2;
    const startY = cy - (h * scale) / 2;
    const colors = { '1': '#000', 'R': '#f00', 'G': '#0f0', 'B': '#00f', 'Y': '#ff0' };
    drawMap(map, startX, startY, scale, colors);
}

// --- CONTROLS ---
function handleStart(e) {
    if (gameState !== 'GAME') return;
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    activePointers[e.pointerId] = { x: e.clientX, startX: e.clientX, startY: e.clientY, startTime: Date.now() };
    input.active = true;
}

function handleMove(e) {
    if (activePointers[e.pointerId]) {
        activePointers[e.pointerId].x = e.clientX;
    }
}

function handleEnd(e) {
    if (gameState !== 'GAME') return;
    const p = activePointers[e.pointerId];
    if (p) {
        const dt = Date.now() - p.startTime;
        const dy = e.clientY - p.startY;
        if (dt < 300 && dy < (-5 * pxScale) && player.ground) {
            const TARGET_H = cvs.height / 3;
            const GRAVITY = pxScale * 0.08;
            const JUMP_VEL = -Math.sqrt(2 * GRAVITY * TARGET_H);
            player.vy = JUMP_VEL;
            player.ground = false;
        }
    }
    delete activePointers[e.pointerId];
    if (Object.keys(activePointers).length === 0) input.active = false;
}

window.addEventListener('pointerdown', handleStart);
window.addEventListener('pointermove', handleMove);
window.addEventListener('pointerup', handleEnd);
window.addEventListener('pointercancel', handleEnd);

init();

</script>
</body>
</html>
