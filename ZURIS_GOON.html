<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Mosaic Jester: High-Vis</title>
<style>
    /* --- CORE LAYOUT --- */
    body { 
        margin: 0; padding: 0; overflow: hidden; 
        background: #eee; 
        font-family: 'Arial Black', sans-serif; 
        touch-action: none; user-select: none; -webkit-user-select: none;
        transition: background-color 0.5s ease;
    }
    canvas { 
        display: block; width: 100%; height: 80vh; /* Canvas takes remaining 80% */
        position: absolute; bottom: 0; left: 0;
        image-rendering: pixelated; 
        transition: transform 0.5s;
    }

    /* --- 4D ANIMATION --- */
    .mode-4d { animation: spinWorld 4s infinite linear; }
    @keyframes spinWorld {
        0% { transform: scale(0.7) rotate(0deg); }
        50% { transform: scale(0.5) rotate(180deg); }
        100% { transform: scale(0.7) rotate(360deg); }
    }

    /* --- MASSIVE HUD (20% Height) --- */
    #hud { 
        position: absolute; top: 0; left: 0; width: 100%; 
        height: 20vh; /* 1/5th of screen */
        background: rgba(255,255,255,0.95); 
        display: flex; flex-direction: column; 
        border-bottom: 4px solid #000; z-index: 10;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        box-sizing: border-box;
        padding: 5px;
    }

    #bars-row {
        display: flex; width: 100%; height: 100%; 
        justify-content: space-around; align-items: center;
        gap: 5px;
    }

    .hud-col { 
        display: flex; flex-direction: column; align-items: center; 
        width: 23%; height: 100%; 
        position: relative;
    }

    /* VIAL STYLE BARS */
    .bar-container { 
        position: relative; width: 100%; flex-grow: 1;
        background: #ddd; border: 3px solid #333; border-radius: 8px; 
        overflow: hidden;
        display: flex; flex-direction: column; justify-content: flex-end;
    }
    
    /* COLORED HEADER (Always visible) */
    .bar-cap {
        position: absolute; top: 0; left: 0; width: 100%; height: 25%;
        z-index: 5;
        border-bottom: 2px solid rgba(0,0,0,0.1);
        display: flex; align-items: center; justify-content: center;
    }
    
    .bar-fill { 
        width: 100%; height: 0%; 
        transition: height 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
        opacity: 0.8;
    }
    
    .bar-txt {
        position: absolute; top: 5px; left: 0; right: 0;
        text-align: center;
        font-size: 14px; color: #fff; 
        text-shadow: 1px 1px 0 #000;
        z-index: 10; font-weight: 900;
    }

    /* Full State (Shake) */
    .bar-container.full { border-color: #000; animation: shake 0.4s infinite; }
    
    /* Spill / Message Text */
    .spill-msg {
        position: absolute; bottom: 5px; left: 0; right: 0;
        font-size: 10px; color: #d00; 
        font-weight: 900; opacity: 0; white-space: nowrap; text-align: center;
        transition: opacity 0.1s; pointer-events: none; z-index: 20;
        text-shadow: 1px 1px 0 #fff;
    }
    .spill-msg.active { opacity: 1; animation: pop 0.1s; }

    /* Timer overlay on HUD */
    #timer { 
        position: absolute; top: 50%; left: 50%; 
        transform: translate(-50%, -50%);
        font-size: 40px; color: rgba(0,0,0,0.05); 
        pointer-events: none; z-index: 0; font-weight: 900;
    }

    /* --- ANIMATIONS --- */
    @keyframes shake {
        0% { transform: translate(1px, 1px) rotate(0deg); }
        20% { transform: translate(-2px, 0px) rotate(1deg); }
        40% { transform: translate(1px, -1px) rotate(1deg); }
        60% { transform: translate(-2px, 1px) rotate(0deg); }
        80% { transform: translate(-1px, -1px) rotate(1deg); }
        100% { transform: translate(1px, -2px) rotate(-1deg); }
    }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }

    /* --- OVERLAY --- */
    #overlay { 
        position: fixed; inset: 0; background: rgba(255,255,255,0.95); 
        display: flex; flex-direction: column; align-items: center; justify-content: center; 
        z-index: 100; transition: opacity 0.3s;
    }
    h1 { font-size: 40px; margin: 0; text-transform: uppercase; letter-spacing: -2px; color: #000; }
    p { color: #666; margin-bottom: 30px; font-weight: normal; font-family: sans-serif; text-align: center; max-width: 300px; line-height: 1.5; }
    button { 
        padding: 20px 60px; font-size: 24px; font-weight: 900; border: 4px solid #000; 
        background: #fff; cursor: pointer; text-transform: uppercase; 
        box-shadow: 6px 6px 0 #000; transition: transform 0.1s;
    }
    button:active { transform: translate(4px, 4px); box-shadow: 2px 2px 0 #000; }
    
    .hidden { opacity: 0; pointer-events: none; }
</style>
</head>
<body>

<div id="hud">
    <div id="timer">60</div>
    <div id="bars-row">
        <div class="hud-col">
            <div class="bar-container" id="con-0">
                <div class="bar-cap" style="background:#ff4444"></div> <div class="bar-txt" id="txt-0">0/10</div>
                <div id="fill-0" class="bar-fill" style="background:#ff4444"></div>
            </div>
            <div id="msg-0" class="spill-msg"></div>
        </div>
        <div class="hud-col">
            <div class="bar-container" id="con-1">
                <div class="bar-cap" style="background:#4466ff"></div>
                <div class="bar-txt" id="txt-1">0/10</div>
                <div id="fill-1" class="bar-fill" style="background:#4466ff"></div>
            </div>
            <div id="msg-1" class="spill-msg"></div>
        </div>
        <div class="hud-col">
            <div class="bar-container" id="con-2">
                <div class="bar-cap" style="background:#00dd44"></div>
                <div class="bar-txt" id="txt-2">0/10</div>
                <div id="fill-2" class="bar-fill" style="background:#00dd44"></div>
            </div>
            <div id="msg-2" class="spill-msg"></div>
        </div>
        <div class="hud-col">
            <div class="bar-container" id="con-3">
                <div class="bar-cap" style="background:#ffdd00"></div>
                <div class="bar-txt" id="txt-3">0/10</div>
                <div id="fill-3" class="bar-fill" style="background:#ffdd00"></div>
            </div>
            <div id="msg-3" class="spill-msg"></div>
        </div>
    </div>
</div>

<div id="overlay">
    <h1 id="title-txt">MOSAIC<br>JESTER</h1>
    <p id="desc-txt">Swipe to Dash. Tap to Jump.<br>Fill the vials. Don't Spill.</p>
    <button onclick="startGame()">INIT</button>
</div>

<canvas id="cvs"></canvas>

<script>
// --- CONFIGURATION ---
const INTERNAL_WIDTH = 320; 
const COLORS = ['#ff4444', '#4466ff', '#00dd44', '#ffdd00'];
const OVERFLOW_BUFFER = 2; 

// --- ASSETS ---
const JESTER_MAP = `
000000001111111100000000
000000011111111110000000
000000111111111111000000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000001111111111111100000
000000111111111111000000
000011001111111100110000
000110000011110000011000
001100110000000011001100
001001111111111111000100
001001101000000101000100
001001101000000101000100
000000111001100111000000
000000011111111110000000
`;

// --- STATE ---
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d', { alpha: true }); 
const bodyEl = document.body;
let msgTimers = [null, null, null, null];

let state = {
    playing: false,
    w: 0, h: 0,
    time: 60, lastTime: 0,
    
    // Logic
    totalNeeded: [10,10,10,10],
    collected: [0,0,0,0],

    // Player
    p: { x:0, y:0, vx:0, vy:0, baseW:20, baseH:20, scale:1, ground:false, facing:1 },
    
    // Effects
    effects: {
        mirror: false,
        fourD: false,
        timer: 0
    },

    entities: [],
    particles: []
};

// --- CORE ---
function init() {
    state.sprite = parseMap(JESTER_MAP, '#222'); 
    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('overlay').classList.add('hidden');
    state.playing = true;
    state.time = 60; 
    state.lastTime = performance.now();
    clearEffects(); 
    state.p.x = state.w / 2;
    state.p.y = state.h - 50;
    state.p.vx = 0;
    state.p.scale = 1;
    state.entities = [];
    state.particles = [];
    
    for(let i=0; i<4; i++) {
        state.totalNeeded[i] = Math.floor(Math.random() * 5) + 8; 
        state.collected[i] = 0;
    }
    updateHUD();
}

function loop(now) {
    if(!state.playing) return requestAnimationFrame(loop);

    let realDt = (now - state.lastTime) / 1000;
    state.lastTime = now;
    
    if(state.effects.timer > 0) {
        state.effects.timer -= realDt;
        if(state.effects.timer <= 0) clearEffects();
    }

    state.time -= realDt; 
    let t = Math.max(0, Math.ceil(state.time));
    document.getElementById('timer').innerText = t < 10 ? `00:0${t}` : `00:${t}`;
    
    if(state.time <= 0) endGame(false);

    update(realDt);
    draw();
    requestAnimationFrame(loop);
}

// --- PHYSICS ---
function update(dt) {
    const p = state.p;
    let curW = p.baseW * p.scale;
    let curH = p.baseH * p.scale;

    p.vx *= 0.88; 
    p.vy += 0.8; 
    
    p.x += p.vx;
    p.y += p.vy;

    let floorY = state.h; 
    if(p.y + curH > floorY) { p.y = floorY - curH; p.vy = 0; p.ground = true; } 
    else p.ground = false;

    if(p.x < 0) { p.x = 0; p.vx = 0; }
    if(p.x + curW > state.w) { p.x = state.w - curW; p.vx = 0; }
    
    if(Math.abs(p.vx) > 0.1) p.facing = p.vx > 0 ? 1 : -1;

    // Spawning logic
    if(Math.random() < 0.045) spawnItem('gem'); 
    if(Math.random() < 0.005) spawnItem('bomb');
    if(Math.random() < 0.008) spawnItem('special'); 

    for(let i=state.entities.length-1; i>=0; i--) {
        let e = state.entities[i];
        e.y += e.speed;
        
        if(p.x < e.x + e.w && p.x + curW > e.x &&
           p.y < e.y + e.h && p.y + curH > e.y) {
            handleCollision(e);
            state.entities.splice(i,1);
        } else if(e.y > state.h + 20) {
            state.entities.splice(i,1);
        }
    }
    
    if(state.particles.length > 50) state.particles.splice(0, state.particles.length - 50);
    state.particles.forEach((pt,i) => {
        pt.x += pt.vx; pt.y += pt.vy; pt.life--;
        pt.vy += 0.5; 
        if(pt.life<=0) state.particles.splice(i,1);
    });
}

function handleCollision(e) {
    if(e.type === 'gem') collectGem(e.idx);
    else if(e.type === 'bomb') hitBomb();
    else if(e.type === 'special') activateSpecial(e.kind);
}

// --- GAME LOGIC ---
function collectGem(idx) {
    if(state.collected[idx] >= state.totalNeeded[idx] + OVERFLOW_BUFFER) {
        triggerOverflow(idx);
        return;
    }
    state.collected[idx]++;
    explode(state.p.x, state.p.y, COLORS[idx], 5);
    updateHUD();
    
    let allDone = true;
    for(let i=0; i<4; i++) if(state.collected[i] < state.totalNeeded[i]) allDone = false;
    if(allDone) endGame(true);
}

function triggerOverflow(idx) {
    showSpillMsg(idx, "SPILLED!");
    explode(state.p.x, state.p.y, '#000', 20);
    state.collected[idx] = 0;
    updateHUD();
}

function hitBomb() {
    explode(state.p.x, state.p.y, '#000', 20);
    let candidates = [];
    for(let i=0; i<4; i++) if(state.collected[i]>0) candidates.push(i);
    
    if(candidates.length > 0) {
        let r = candidates[Math.floor(Math.random()*candidates.length)];
        let lost = Math.min(3, state.collected[r]);
        state.collected[r] -= lost;
        showSpillMsg(r, `-${lost}`);
    } else {
        document.body.style.transform = "translateX(5px)";
        setTimeout(()=>document.body.style.transform = "translateX(0)", 50);
    }
    updateHUD();
}

function showSpillMsg(idx, text) {
    const el = document.getElementById(`msg-${idx}`);
    el.innerText = text;
    el.classList.add('active');
    if (msgTimers[idx]) clearTimeout(msgTimers[idx]);
    msgTimers[idx] = setTimeout(() => { el.classList.remove('active'); }, 1500);
}

function activateSpecial(kind) {
    clearEffects(); 
    state.effects.timer = 8.0; 

    if(kind === 'mirror') {
        state.effects.mirror = true;
        bodyEl.style.backgroundColor = "#ccc"; 
        showGlobalMsg("MIRROR");
    } else if(kind === '4d') {
        state.effects.fourD = true;
        cvs.classList.add('mode-4d');
        bodyEl.style.backgroundColor = "#e0c0e0"; 
        showGlobalMsg("4D MODE");
    } else if(kind === 'grow') {
        state.p.scale = 2.0;
        showGlobalMsg("GIANT");
    } else if(kind === 'shrink') {
        state.p.scale = 0.5;
        showGlobalMsg("TINY");
    }
}

function showGlobalMsg(txt) {
    let t = document.getElementById('timer');
    let old = t.innerText;
    t.innerText = txt;
    t.style.color = "#d00";
    setTimeout(()=>{ t.innerText = old; t.style.color = "rgba(0,0,0,0.05)"; }, 1500);
}

function clearEffects() {
    state.effects.mirror = false;
    state.effects.fourD = false;
    state.p.scale = 1.0;
    cvs.classList.remove('mode-4d');
    bodyEl.style.backgroundColor = "#eee"; 
}

function spawnItem(type) {
    let x = Math.random() * (state.w - 30) + 15;
    let baseSpeed = (2.5 + Math.random() * 2); 
    
    if(type === 'gem') {
        state.entities.push({type:'gem', x, y:-20, w:16, h:16, idx:Math.floor(Math.random()*4), speed: baseSpeed});
    } else if(type === 'bomb') {
        state.entities.push({type:'bomb', x, y:-20, w:18, h:18, speed: baseSpeed + 0.5});
    } else if(type === 'special') {
        // --- 4D LOGIC CHECK ---
        const kinds = ['mirror', 'mirror', 'grow', 'grow', 'shrink', 'shrink', '4d'];
        let kind = kinds[Math.floor(Math.random()*kinds.length)];

        // If 4D is rolled, check if we have 3 full buckets
        if(kind === '4d') {
            let fullBuckets = 0;
            for(let i=0; i<4; i++) {
                if(state.collected[i] >= state.totalNeeded[i]) fullBuckets++;
            }
            // If less than 3 buckets are full, swap 4d for something else (e.g., grow)
            if(fullBuckets < 3) {
                kind = 'grow';
            }
        }

        state.entities.push({type:'special', kind, x, y:-20, w:20, h:20, speed: 2.5});
    }
}

// --- RENDER ---
function draw() {
    ctx.clearRect(0,0,state.w, state.h);
    
    const p = state.p;
    let curW = p.baseW * p.scale;
    let curH = p.baseH * p.scale;

    // Player
    ctx.save();
    ctx.translate(p.x + curW/2, p.y + curH/2);
    ctx.scale(p.facing, 1);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(state.sprite, -curW/2, -curH/2, curW, curH);

    // Mini-Hat Progress
    let hatW = (curW/24); 
    let hatH = (curH/21);
    let hatOX = -curW/2 + (6 * hatW); 
    let hatOY = -curH/2 + (2 * hatH);
    let tileW = 3 * hatW; 
    let tileH = 3 * hatH;

    for(let i=0; i<4; i++) {
        let pct = state.collected[i] / state.totalNeeded[i];
        pct = Math.min(pct, 1);
        let fillCount = Math.floor(pct * 4);
        ctx.fillStyle = COLORS[i];
        for(let k=0; k<fillCount; k++) {
            ctx.fillRect(hatOX + (k * tileW), hatOY + (i * tileH), tileW, tileH);
        }
    }
    ctx.restore();

    // Entities
    state.entities.forEach(e => {
        if(e.type === 'gem') drawPixelGem(ctx, e.x, e.y, COLORS[e.idx]);
        else if(e.type === 'bomb') drawBomb(ctx, e.x, e.y);
        else if(e.type === 'special') drawSpecial(ctx, e);
    });

    state.particles.forEach(pt => { ctx.fillStyle=pt.c; ctx.fillRect(pt.x,pt.y,4,4); });
}

function drawSpecial(ctx, e) {
    let x=Math.floor(e.x), y=Math.floor(e.y);
    ctx.fillStyle = '#8e44ad'; 
    ctx.fillRect(x,y,20,20);
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(x,y,20,20);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    let icon = "?";
    if(e.kind==='mirror') icon="M";
    if(e.kind==='4d') icon="4";
    if(e.kind==='grow') icon="G";
    if(e.kind==='shrink') icon="S";
    ctx.fillText(icon, x+10, y+10);
}

function drawBomb(ctx, x, y) {
    x=Math.floor(x); y=Math.floor(y);
    ctx.fillStyle = '#000'; ctx.fillRect(x+2, y+2, 14, 14);
    ctx.fillStyle = '#f00'; ctx.fillRect(x+8, y-2, 2, 4); 
}

function drawPixelGem(ctx, x, y, c) {
    x=Math.floor(x); y=Math.floor(y);
    ctx.fillStyle = '#222'; ctx.fillRect(x, y, 16, 16); 
    ctx.fillStyle = c; ctx.fillRect(x+2, y+2, 12, 12); 
    ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(x+4, y+4, 4, 4); 
}

function updateHUD() {
    for(let i=0; i<4; i++) {
        let cur = state.collected[i];
        let tot = state.totalNeeded[i];
        
        const con = document.getElementById(`con-${i}`);
        const fill = document.getElementById(`fill-${i}`);
        const txt = document.getElementById(`txt-${i}`);
        
        let pct = Math.min((cur / tot) * 100, 100);
        
        fill.style.height = `${pct}%`;
        
        if (cur >= tot) {
            con.classList.add('full');
            txt.innerText = "OK";
            if(cur > tot + OVERFLOW_BUFFER) {
                fill.style.backgroundColor = "#000"; 
            } else {
                fill.style.backgroundColor = COLORS[i];
            }
        } else {
            con.classList.remove('full');
            txt.innerText = `${cur}/${tot}`;
            fill.style.backgroundColor = COLORS[i];
        }
    }
}

// --- INPUT ---
let tx=0, ty=0;
window.addEventListener('touchstart', e=>{ tx=e.touches[0].clientX; ty=e.touches[0].clientY; }, {passive:false});
window.addEventListener('touchend', e=>{
    if(e.target.tagName==='BUTTON') return;
    let dx = e.changedTouches[0].clientX - tx;
    let dy = e.changedTouches[0].clientY - ty;

    if(dy < -30 && Math.abs(dy) > Math.abs(dx)) { 
        if(state.p.ground) { state.p.vy = -12; state.p.ground=false; } 
    } 
    else if(Math.abs(dx) > 10) {
        let dir = dx > 0 ? 1 : -1;
        if(state.effects.mirror) dir = -dir;
        state.p.vx = dir * 5.0; 
    }
});

function parseMap(str, color) {
    let lines = str.trim().split(/\n+/);
    let c = document.createElement('canvas');
    c.width = lines[0].length; c.height = lines.length;
    let cx = c.getContext('2d');
    cx.fillStyle = color; 
    lines.forEach((row,y) => { for(let x=0; x<row.length; x++) if(row[x]==='1') cx.fillRect(x,y,1,1); });
    return c;
}

function explode(x,y,c,n) { for(let i=0; i<n; i++) state.particles.push({x,y,vx:(Math.random()-.5)*6,vy:(Math.random()-.5)*6,c,life:25}); }

function resize() { 
    let aspect = window.innerHeight / window.innerWidth;
    state.w = INTERNAL_WIDTH;
    state.h = INTERNAL_WIDTH * aspect;
    cvs.width = state.w;
    cvs.height = state.h;
    state.p.y = state.h - 50;
}

function endGame(win) {
    state.playing = false;
    document.getElementById('overlay').classList.remove('hidden');
    document.getElementById('title-txt').innerText = win ? "RESTORED" : "FAILED";
    document.getElementById('desc-txt').innerText = win ? "Mosaic Complete." : "Try again.";
    clearEffects();
}

init();
</script>
</body>
</html>
