<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Sir Jester's Responsive Quest</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body { 
        margin: 0; padding: 0; overflow: hidden; 
        background: #fff; 
        font-family: 'Press Start 2P', cursive;
        touch-action: none; user-select: none; -webkit-user-select: none; 
    }
    
    canvas { display: block; width: 100%; height: 100%; }

    /* UI LAYERS */
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        display: flex; flex-direction: column; justify-content: space-between;
    }

    /* STORY BOX */
    #story-container {
        position: absolute; bottom: 5%; left: 5%; width: 90%;
        background: #fff; border: 0.5vmin solid #000;
        padding: 2vmin; box-sizing: border-box;
        text-align: center; pointer-events: auto;
        box-shadow: 1vmin 1vmin 0px rgba(0,0,0,0.2);
    }

    #story-text {
        font-size: 2.5vmin; line-height: 1.6; color: #000; margin-bottom: 2vmin;
        min-height: 10vmin; display: flex; align-items: center; justify-content: center;
    }

    /* BUTTONS */
    .btn {
        background: #000; color: #fff; border: 0.4vmin solid #000; 
        padding: 1.5vmin 4vmin; font-family: inherit; font-size: 2.5vmin;
        cursor: pointer; box-shadow: 0.5vmin 0.5vmin 0 #888;
        display: inline-block;
    }
    .btn:active { transform: translate(0.3vmin, 0.3vmin); box-shadow: 0.2vmin 0.2vmin 0 #888; }

    /* TOP NAVIGATION BAR */
    #game-hud {
        position: absolute; top: 0; left: 0; width: 100%;
        display: none; /* Flex when active */
        flex-direction: row; 
        align-items: center; 
        justify-content: space-evenly;
        background: rgba(255,255,255,0.95);
        border-bottom: 0.5vmin solid #000;
        padding: 1vmin 0;
        box-sizing: border-box;
        pointer-events: none;
    }

    /* TIMER - Inside Navbar */
    #timer {
        font-size: 2.5vmin; color: #000; 
        padding: 0 1vmin;
        white-space: nowrap;
    }

    .hud-row {
        display: flex; align-items: center; gap: 0.5vmin;
        background: #fff;
        padding: 0.5vmin; border: 0.3vmin solid #000;
        position: relative;
        flex-grow: 1;
        max-width: 20%; /* Distribute space */
        margin: 0 0.5vmin;
    }
    
    .color-icon { 
        width: 2.5vmin; height: 2.5vmin; 
        border: 0.3vmin solid #000; flex-shrink: 0; 
    }
    
    /* PROGRESS BARS */
    .bar-container {
        flex-grow: 1; height: 2vmin; background: #ccc; border: 0.2vmin solid #000;
        position: relative;
    }
    .bar-fill {
        height: 100%; width: 0%; 
        transition: width 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28); 
    }
    .hud-txt { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 1.2vmin; color: #000; text-shadow: 0.2vmin 0.2vmin 0 #fff; z-index: 2;
    }

    /* SPILL MESSAGE - Floats down from navbar now */
    .spill-msg {
        position: absolute; top: 120%; left: 50%; transform: translateX(-50%);
        font-size: 2vmin; color: #d00; white-space: nowrap; 
        font-weight: bold; opacity: 0; pointer-events: none;
        text-shadow: 0.2vmin 0.2vmin 0 #fff;
        background: rgba(255,255,255,0.8);
    }
    .spill-anim {
        animation: floatDown 1s ease-out forwards;
    }

    @keyframes floatDown {
        0% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
        100% { opacity: 0; transform: translateX(-50%) translateY(2vmin) scale(1.2); }
    }

    /* MAX VIBRATION */
    @keyframes vibrate {
        0% { transform: translate(0); }
        20% { transform: translate(-0.3vmin, 0.3vmin); }
        40% { transform: translate(-0.3vmin, -0.3vmin); }
        60% { transform: translate(0.3vmin, 0.3vmin); }
        80% { transform: translate(0.3vmin, -0.3vmin); }
        100% { transform: translate(0); }
    }
    .hud-row.max {
        border-color: #d00;
        animation: vibrate 0.3s linear infinite;
        background: #fff0f0;
    }
    .hud-row.max .hud-txt { color: #d00; font-weight: bold; }

    /* END SCREEN BARS */
    #end-bars {
        display: none; width: 100%; max-width: 50vmin;
        margin: 2vmin auto;
        background: #eee; padding: 2vmin; border: 0.4vmin solid #000;
        box-sizing: border-box;
    }
    .end-row {
        display: flex; align-items: center; justify-content: space-between;
        margin-bottom: 1.5vmin; font-size: 2vmin; width: 100%;
    }
    .end-label { width: 3vmin; text-align: center; font-weight: bold; }
    .progress-track {
        flex-grow: 1; height: 3vmin; background: #ccc; margin: 0 2vmin; border: 0.3vmin solid #000;
        position: relative;
    }

</style>
</head>
<body oncontextmenu="return false;">

<div id="ui-layer">
    
    <div id="game-hud">
        <div id="timer">1:30</div>

        <div class="hud-row" id="row-R">
            <div class="spill-msg" id="msg-R"></div>
            <div class="color-icon" style="background:#f00"></div>
            <div class="bar-container"><div id="bar-R" class="bar-fill" style="background:#f00"></div><span id="cnt-R" class="hud-txt">0/3</span></div>
        </div>
        <div class="hud-row" id="row-Y">
            <div class="spill-msg" id="msg-Y"></div>
            <div class="color-icon" style="background:#ff0"></div>
            <div class="bar-container"><div id="bar-Y" class="bar-fill" style="background:#ff0"></div><span id="cnt-Y" class="hud-txt">0/2</span></div>
        </div>
        <div class="hud-row" id="row-B">
            <div class="spill-msg" id="msg-B"></div>
            <div class="color-icon" style="background:#00f"></div>
            <div class="bar-container"><div id="bar-B" class="bar-fill" style="background:#00f"></div><span id="cnt-B" class="hud-txt">0/4</span></div>
        </div>
        <div class="hud-row" id="row-G">
            <div class="spill-msg" id="msg-G"></div>
            <div class="color-icon" style="background:#0f0"></div>
            <div class="bar-container"><div id="bar-G" class="bar-fill" style="background:#0f0"></div><span id="cnt-G" class="hud-txt">0/1</span></div>
        </div>
    </div>

    <div id="story-container">
        <div id="story-text">Loading...</div>
        
        <div id="end-bars"></div>

        <button id="main-btn" class="btn" onclick="handleBtn()">NEXT ></button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// --- CONFIG ---
const MAX_TIME = 90; 
const COLORS = { R:'#f00', Y:'#ff0', B:'#00f', G:'#0f0' };
const LIGHT_COLORS = { R:'#f88', Y:'#ffb', B:'#66f', G:'#6f6' }; 

let TARGETS = { R:0, Y:0, B:0, G:0 }; 
let REGION_MAP = {}; 

// --- ASSETS ---
const JESTER_MAP = [
    ".......#.#.......",
    "......#A#B#......", 
    ".....#A#C#B#.....", 
    ".....#######.....",
    ".....#.....#.....", 
    ".....#######.....",
    "....##DDDDD##....", 
    "...#E#FFFFF#G#...", 
    "...#E#FFFFF#G#...", 
    "..##E#######G##..",
    "..#HH#.....#II#..", 
    "..#HH#.....#II#..",
    ".#JJ#.......#KK#.", 
    ".####.......####."
];

const GEM_SPRITE = [
    "...#...",
    "..#A#..",
    ".#AMA#.",
    "#MAMAM#",
    ".#MMM#.",
    "..#M#..",
    "...#..."
];

const ADJACENCY = {
    'A': ['C'], 'B': ['C'], 'C': ['A', 'B', 'D'], 
    'D': ['C', 'E', 'F', 'G'], 'E': ['D', 'F', 'H'],
    'F': ['D', 'E', 'G', 'H', 'I'], 'G': ['D', 'F', 'I'],
    'H': ['E', 'F', 'J'], 'I': ['F', 'G', 'K'],
    'J': ['H'], 'K': ['I']
};

const SPRITES = {
    PRINCESS_HAPPY: [
        "...11111...", "..1111111..", ".111111111.", ".1.1.1.1.1.", ".111111111.",
        "..1111111..", "..1111111..", ".111111111.", "11111111111"
    ],
    PRINCESS_MAD: [
        "...11111...", "..1111111..", ".11R111R11.", ".1.1.1.1.1.", ".111111111.",
        "..1111111..", "..1111111..", ".111111111.", "11111111111"
    ],
    HAT: [ "...Y...", "..YRY..", ".YRYRY.", "YRYRYRY", "GBGBGBG", ".GBGBG.", "..GBG.." ]
};

const STORY = [
    { txt: "Sir Jester loves his job!\nHe makes the princess laugh.", s1: 'PLAYER', s2: 'PRINCESS_HAPPY', anim: 'hop' },
    { txt: "But recently there's been an issue...", s1: 'PLAYER', s2: 'PRINCESS_MAD', anim: 'shake' },
    { txt: "The princess has been sad...", s1: 'PRINCESS_MAD', scaleMulti: 1.5, anim: 'hop' },
    { txt: "And this makes Sir Jester sad too...", s1: 'PLAYER', scaleMulti: 1.5, anim: 'hop' },
    { txt: "But Sir Jester has an idea!", s1: 'PLAYER', scaleMulti: 1.5, anim: 'jump' },
    { txt: "To make a colorful hat\nand make her laugh again.", s1: 'HAT', scaleMulti: 2.0, anim: 'float' },
    { txt: "FLICK UP to Jump!\nCollect the gems!", s1: 'PLAYER', jump: true, anim: 'run' }
];

// --- ENGINE VARIABLES ---
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let pxScale = 1; 

let gameState = 'STORY'; 
let slideIdx = 0;
let timeLeft = MAX_TIME;

let player = { x: 0, y: 0, w: 0, h: 0, vx: 0, vy: 0, ground: false };
let spillTimer = 0; 
let spillColor = '#fff';
let activePointers = {}; 
let items = [];
let particles = [];
let collected = { R:0, Y:0, B:0, G:0 };
let winCondition = false;

// --- INITIALIZATION ---
function init() {
    window.addEventListener('resize', resize);
    window.addEventListener('contextmenu', e => e.preventDefault());
    generateColorMap(); 
    resize();
    updateStoryUI();
    requestAnimationFrame(loop);
}

function generateColorMap() {
    const regions = Object.keys(ADJACENCY);
    const colorKeys = ['R', 'Y', 'B', 'G'];
    const assignments = {};
    regions.sort(() => Math.random() - 0.5);

    for (let r of regions) {
        let choices = [...colorKeys].sort(() => Math.random() - 0.5);
        let validColor = null;

        for (let c of choices) {
            let conflict = false;
            for (let neighbor of ADJACENCY[r]) {
                if (assignments[neighbor] === c) { conflict = true; break; }
            }
            if (!conflict) { validColor = c; break; }
        }
        assignments[r] = validColor || choices[0];
    }

    REGION_MAP = {};
    TARGETS = { R:0, Y:0, B:0, G:0 };
    let colorCounts = { R:0, Y:0, B:0, G:0 };
    const sortedRegions = Object.keys(ADJACENCY).sort();
    
    for (let r of sortedRegions) {
        let c = assignments[r];
        colorCounts[c]++;
        REGION_MAP[r] = { c: c, i: colorCounts[c] };
    }
    TARGETS = colorCounts;
}

function resize() {
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;
    let targetH = cvs.height / 5;
    pxScale = targetH / 14; 
    player.w = 17 * pxScale;
    player.h = 14 * pxScale;
    if(player.y > cvs.height) player.y = cvs.height - player.h - 5;
}

function loop() {
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    if (gameState === 'STORY') drawStory(); 
    else if (gameState === 'GAME') { updatePhysics(); drawGame(); }
    else if (gameState === 'END') drawEndScene();
    requestAnimationFrame(loop);
}

// --- STORY ---
function updateStoryUI() {
    if(gameState !== 'STORY') return;
    const s = STORY[slideIdx];
    document.getElementById('story-text').innerText = s.txt;
    const btn = document.getElementById('main-btn');
    btn.innerText = (slideIdx === STORY.length - 1) ? "START GAME" : "NEXT >";
}

function handleBtn() {
    if (gameState === 'STORY') {
        slideIdx++;
        if (slideIdx >= STORY.length) startGame();
        else updateStoryUI();
    } else if (gameState === 'END') {
        location.reload(); 
    }
}

function drawStory() {
    const s = STORY[slideIdx];
    const cx = cvs.width / 2;
    const cy = cvs.height / 2 - player.h; 
    const scale = (s.scaleMulti || 1) * pxScale * 0.8; 
    
    let yOff = 0;
    let t = Date.now();
    if (s.anim === 'hop') yOff = Math.abs(Math.sin(t/300)) * -20;
    if (s.anim === 'float') yOff = Math.sin(t/500) * 10;
    if (s.anim === 'jump') yOff = Math.abs(Math.sin(t/150)) * -30;

    if (s.s2) {
        drawCustomSprite(s.s1, cx - (scale*10), cy + yOff, scale);
        drawCustomSprite(s.s2, cx + (scale*10), cy + yOff, scale);
    } else {
        drawCustomSprite(s.s1, cx, cy + yOff, scale);
    }
}

// --- GAME ---
function startGame() {
    gameState = 'GAME';
    document.getElementById('story-container').style.display = 'none';
    document.getElementById('game-hud').style.display = 'flex';
    
    player.x = cvs.width/2 - player.w/2;
    player.y = cvs.height - player.h - 10;
    player.vx = 0; player.vy = 0;
    
    collected = { R:0, Y:0, B:0, G:0 };
    updateHUD();
}

function updatePhysics() {
    timeLeft -= 0.016;
    let m = Math.floor(timeLeft/60);
    let s = Math.floor(timeLeft%60);
    document.getElementById('timer').innerText = `${m}:${s<10?'0'+s:s}`;
    if(timeLeft <= 0) endGame(false);

    // Input (Horizontal Only)
    let moveDir = 0;
    const center = cvs.width / 2;
    for (let id in activePointers) {
        const p = activePointers[id];
        if (p.x < center) moveDir = -1;
        if (p.x > center) moveDir = 1;
    }

    // Movement
    const accel = pxScale * 0.2;
    const maxSpd = pxScale * 1.5;
    
    if (moveDir !== 0) player.vx += moveDir * accel;
    else {
        if (player.ground) player.vx *= 0.6; 
        else player.vx *= 0.96; 
    }

    player.vx = Math.max(-maxSpd, Math.min(maxSpd, player.vx));
    if (Math.abs(player.vx) < 0.1) player.vx = 0;

    player.vy += pxScale * 0.08; 
    player.x += player.vx;
    player.y += player.vy;

    const FLOOR = cvs.height - player.h - 5;
    if (player.y > FLOOR) { player.y = FLOOR; player.vy = 0; player.ground = true; }

    if (player.x < 0) { player.x = 0; player.vx = 0; }
    if (player.x > cvs.width - player.w) { player.x = cvs.width - player.w; player.vx = 0; }
    
    if (spillTimer > 0) spillTimer--;

    // Spawning
    let difficulty = (MAX_TIME - timeLeft) / MAX_TIME; 
    let spawnRate = 0.03 + (difficulty * 0.08); 
    if (Math.random() < spawnRate) spawnItem();

    for (let i = items.length - 1; i >= 0; i--) {
        let it = items[i];
        
        // SPEED: 1.5x on top of previous 0.9 = 1.35
        it.y += pxScale * 1.35; 

        if (checkRectCollide(player, {x:it.x, y:it.y, w:it.w, h:it.h})) {
            if (collected[it.type] >= TARGETS[it.type]) {
                triggerSpill(it.type);
            } else {
                collected[it.type]++;
                updateHUD();
                checkWin();
            }
            items.splice(i, 1);
        } else if (it.y > cvs.height) {
            items.splice(i, 1);
        }
    }

    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vy += pxScale * 0.05;
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    }
}

function triggerSpill(type) {
    let current = collected[type];
    if (current <= 0) return; 
    
    let loss = Math.floor(Math.random() * 3) + 1;
    if (loss > current) loss = current;
    
    collected[type] -= loss;

    spillTimer = 20; 
    spillColor = COLORS[type]; 
    
    for(let i=0; i<loss*3; i++) {
        particles.push({
            x: player.x + player.w/2,
            y: player.y + player.h/2,
            vx: (Math.random() - 0.5) * (pxScale * 2),
            vy: -(Math.random() * (pxScale * 2)),
            color: COLORS[type],
            life: 60,
            size: player.w / 6
        });
    }

    updateHUD();
    showSpillText(type, loss);
}

function showSpillText(type, amount) {
    const el = document.getElementById(`msg-${type}`);
    el.innerText = `-${amount} SPILLED!`;
    el.classList.remove('spill-anim');
    void el.offsetWidth; 
    el.classList.add('spill-anim');
}

function spawnItem() {
    const keys = ['R', 'Y', 'B', 'G'];
    const type = keys[Math.floor(Math.random() * keys.length)];
    const gSize = player.w * 0.35; 
    items.push({
        x: Math.random() * (cvs.width - gSize),
        y: -gSize, w: gSize, h: gSize, type: type, color: COLORS[type]
    });
}

function checkRectCollide(p, it) {
    return (p.x < it.x + it.w && p.x + p.w > it.x &&
            p.y < it.y + it.h && p.y + p.h > it.y);
}

function updateHUD() {
    for(let k in TARGETS) {
        if(TARGETS[k] === 0) {
            document.getElementById(`row-${k}`).style.display = 'none';
            continue;
        } else {
            document.getElementById(`row-${k}`).style.display = 'flex';
        }

        let el = document.getElementById(`cnt-${k}`);
        let row = document.getElementById(`row-${k}`);
        let bar = document.getElementById(`bar-${k}`);
        
        let cur = collected[k];
        let tot = TARGETS[k];
        let pct = (cur / tot) * 100;
        
        bar.style.width = `${pct}%`;

        if(cur >= tot) {
            el.innerText = "MAX";
            row.classList.add('max');
        } else {
            el.innerText = `${cur}/${tot}`;
            row.classList.remove('max');
        }
    }
}

function checkWin() {
    let win = true;
    for(let k in TARGETS) if(collected[k] < TARGETS[k]) win = false;
    if(win) endGame(true);
}

function endGame(win) {
    gameState = 'END';
    winCondition = win;
    
    document.getElementById('game-hud').style.display = 'none';
    const box = document.getElementById('story-container');
    box.style.display = 'block';
    const txt = document.getElementById('story-text');
    if (win) txt.innerHTML = "It’s the perfect color combo!<br>The princess loves your hat!<br>She can’t stop laughing!";
    else txt.innerHTML = "There’s not enough colors...<br>The princess thinks your hat is ugly.<br>She guillotines you.";

    document.getElementById('end-bars').style.display = 'block';
    const barBox = document.getElementById('end-bars');
    barBox.innerHTML = ''; 
    for(let k in TARGETS) {
        if(TARGETS[k] === 0) continue; 
        
        let pct = Math.min(100, (collected[k] / TARGETS[k]) * 100);
        
        barBox.innerHTML += `
            <div class="end-row">
                <span class="end-label">${k}</span>
                <div class="progress-track"><div class="bar-fill" style="background:${COLORS[k]}; width:${pct}%"></div></div>
                <span class="end-label">${collected[k]}/${TARGETS[k]}</span>
            </div>`;
    }
    document.getElementById('main-btn').innerText = "TRY AGAIN";
}

// --- RENDERERS ---
function drawGame() {
    let bob = Math.sin(Date.now() / (Math.abs(player.vx) > 0.1 ? 50 : 300)) * (player.h * 0.05);
    let shakeX = 0;
    if (spillTimer > 0) shakeX = (Math.random() - 0.5) * (pxScale * 2);

    drawPlayerSprite(player.x + shakeX, player.y + bob, pxScale);
    
    items.forEach(it => {
        const colorMap = {
            '#': '#000',
            'M': it.color,
            'A': LIGHT_COLORS[it.type] 
        };
        drawMap(GEM_SPRITE, it.x, it.y, pxScale * 0.8, colorMap);
    });

    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 60;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.globalAlpha = 1.0;
    });
}

function drawEndScene() {
    const cx = cvs.width/2;
    const cy = cvs.height/2 - (player.h * 1.5); 
    const scale = pxScale * 1.5; 
    
    if (winCondition) {
        drawCustomSprite('PRINCESS_HAPPY', cx + (15*pxScale), cy, scale);
        drawPlayerSprite(cx - (15*pxScale), cy + (5*pxScale), scale);
    } else {
        drawCustomSprite('PRINCESS_MAD', cx + (15*pxScale), cy, scale);
        drawPlayerSprite(cx - (15*pxScale), cy + (5*pxScale), scale);
    }
}

function drawMap(map, x, y, scale, colorMap) {
    const w = map[0].length;
    const h = map.length;
    for(let r=0; r<h; r++) {
        for(let c=0; c<w; c++) {
            let char = map[r][c];
            if (char === '.') continue;
            ctx.fillStyle = colorMap[char] || '#000';
            ctx.fillRect(x + c*scale, y + r*scale, scale+0.5, scale+0.5);
        }
    }
}

function drawPlayerSprite(x, y, scale) {
    const map = JESTER_MAP;
    const w = map[0].length;
    const h = map.length;

    for(let r=0; r<h; r++) {
        for(let c=0; c<w; c++) {
            let char = map[r][c];
            if (char === '.') continue;
            
            ctx.fillStyle = '#fff';
            if (char === '#') ctx.fillStyle = '#000';
            else if (REGION_MAP[char]) {
                const reg = REGION_MAP[char];
                if (spillTimer > 0 && Math.floor(spillTimer / 4) % 2 === 0) {
                    ctx.fillStyle = spillColor; 
                }
                else if (collected[reg.c] >= reg.i) {
                    ctx.fillStyle = COLORS[reg.c];
                } 
                else {
                    ctx.fillStyle = '#ddd';
                }
            }
            ctx.fillRect(x + c*scale, y + r*scale, scale+0.5, scale+0.5);
        }
    }
}

function drawCustomSprite(name, cx, cy, scale) {
    if (name === 'PLAYER') {
        drawPlayerSprite(cx - (17*scale)/2, cy - (14*scale)/2, scale);
        return;
    }
    const map = SPRITES[name];
    if(!map) return;
    const w = map[0].length;
    const h = map.length;
    const startX = cx - (w * scale) / 2;
    const startY = cy - (h * scale) / 2;
    
    const colors = {
        '1': '#000', 'R': '#f00', 'G': '#0f0', 'B': '#00f', 'Y': '#ff0'
    };
    drawMap(map, startX, startY, scale, colors);
}

// --- CONTROLS ---
function handleStart(e) {
    if (gameState !== 'GAME') return;
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    activePointers[e.pointerId] = { x: e.clientX, startX: e.clientX, startY: e.clientY, startTime: Date.now() };
    input.active = true;
}

function handleMove(e) {
    if (activePointers[e.pointerId]) {
        activePointers[e.pointerId].x = e.clientX;
    }
}

function handleEnd(e) {
    if (gameState !== 'GAME') return;
    const p = activePointers[e.pointerId];
    if (p) {
        const dt = Date.now() - p.startTime;
        const dy = e.clientY - p.startY;
        
        // FLICK JUMP LOGIC: Reduced threshold to 5px scale (Very Sensitive)
        if (dt < 300 && dy < (-5 * pxScale) && player.ground) {
            const TARGET_H = cvs.height / 3;
            const GRAVITY = pxScale * 0.08;
            const JUMP_VEL = -Math.sqrt(2 * GRAVITY * TARGET_H);
            player.vy = JUMP_VEL;
            player.ground = false;
        }
    }
    delete activePointers[e.pointerId];
    if (Object.keys(activePointers).length === 0) input.active = false;
}

window.addEventListener('pointerdown', handleStart);
window.addEventListener('pointermove', handleMove);
window.addEventListener('pointerup', handleEnd);
window.addEventListener('pointercancel', handleEnd);

init();

</script>
</body>
</html>
